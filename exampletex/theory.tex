{\let\cleardoublepage\relax \chapter{Przyswajanie wiedzy}}

\todo[inline]{Jeśli opisuje coś na podstawie strony internetowej pana Doktora to czy to jest plagiat?}

Hermann Ebbinghaus\cite{HumanMemory} (1850-1909) był Niemieckim psychologiem, który jako jeden z pierwszych zajmował się tematyką eksperymentalnej psychologii związanej z przyswajaniem wiedzy. 
Jednym z jego pierwszych eksperymentów było stworzenie testu, podczas którego uczył się zestawu 20 sylab, które były bezsensowne ze względu na fakt, iż w jego języku nie występowały żadne słowa, które ich używały.
Eksperyment ten pozwolił mu skonstruować pierwszą na świecie krzywą zapominania. Miała ona charakter eksponencjalny.  Możemy z niej wywnioskować, iż podczas początkowego okresu zapominania tracimy najwięcej zapamiętanych informacji.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{images/curve.png}
	 \caption{Eksponencjalna krzywa zapominania.}
\end{figure}

Trzeba także zwrócić uwagę na fakt, iż w rzeczywistości\cite{ForgettingCurve} nasz mózg nie jest w stanie przyswoić danych informacji w 100\% po zakończeniu nauki. 

\section{Interwały potwórzeń}

W celu jak najlepszego zapamiętania wyuczonych informacji należy, poza odpowiednim programem nauczania, zwrócić uwagę na fakt, w jakich interwałach czasowych powtarzamy przerabiany materiał\cite{ForgettingCurve}.
Interwał musi być wystarczająco krótki, aby zapobiec zapominaniu i wystarczająco długi, aby zbyt często nie przyswajać powtarzanego materiału.



\todo[inline]{Można tu jeszcze coś napisać}



{\let\cleardoublepage\relax \chapter{.NET}}
\label{cha:wstep}

%https://docs.microsoft.com/en-us/dotnet/standard/tour
.NET jest platformą programistyczną umożliwiającą pisanie nowoczesnych aplikacji w językach wysokiego poziomu, do których zalicza się m.in C\#, VB oraz F\#. Platforma ta wyróżnia się tym iż:
\begin{itemize}
	\item Pozwala na użycie wielu języków programowania podczas pisania naszych programów.
	\item Ma zaimplementowane mechanizmy do obsługi operacji asynchronicznych i współbieżnych.
	\item Można ją stosować na różnych platformach, które posiadają środowisko wykonywalne .NET.
\end{itemize}
Wszystkie języki używane w platformie .NET kompilowane są do Wspólnego Języka Pośredniego (po ang. \textit{Common Intermediate Language}), który następnie jest tłumaczony na kod bajtowy i wykonywany za pomocą środowiska wykonywalnego danej implementacji .NET.

\begin{lstlisting}[frame=single, numbers=none,captionpos=b, 
caption={Przykładowy kod aplikacji "Hello World" w języku CIL}]
.assembly HelloWorld
.class auto ansi HelloWorldApp
{
     .method public hidebysig static void Main() cil managed
     {
          .entrypoint
          .maxstack 1
          ldstr "Hello world."
          call void [mscorlib]System.Console::WriteLine(string)
          ret
     }
}
\end{lstlisting}

%https://docs.microsoft.com/en-us/dotnet/standard/tour
% CLI ECMA http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf

\section{Implementacje .NET}

Każda aplikacja .NET jest uruchamiana na jednej z implementacji .NET. \\
Od roku 2016 wprowadzono .NET Standard - wspólny zestaw API, które każda z implementacji musi posiadać. Pozwala to na pisanie i używanie bibliotek programistycznych w różnych środowiskach .NET.

Istnieją aktualnie 4 główne implementacje .NET:

%https://docs.microsoft.com/en-us/dotnet/standard/components
\subsection{.NET Core}
Został napisany z myślą o tworzeniu aplikacji cross-platformowych, które mogą zostać uruchomione na serwerach, jak i środowiskach chmurowych. Potrafi działać na platformie Windows, macOS oraz Linux. Jest to pierwsza implementacja .NET, która została zaprojektowana przez Microsoft z myślą o wieloplatformowości.

%https://docs.microsoft.com/en-us/dotnet/framework/get-started/overview
\subsection{.NET Framework}
Jest to pierwsza, oryginalna implementacja .NET, która istnieje od roku 2002. Składa się ze środowiska uruchomieniowego Common Language Runtime (CLR) oraz biblioteki standardowej zwanej jako Framework Class Library (FCL). CLR zapewnia aplikacjom wirtualną maszynę, na której wykonywany kod bajtowy skompilowany z języka CIL. Ta implementacja jest używana w tej pracy inżynierskiej.

%http://www.mono-project.com/docs/about-mono/
\subsection{Mono}
Darmowy projekt open-source prowadzony przez firmę Xamarin. Powodem stworzenia tego produktu była możliwość uruchamiania aplikacji napisanych w językach .NET na wielu platformach, jak i dostarczenie użytkownikom Linuxa narzędzi pozwalających na aplikacji w rodzinie języków .NET.
%https://docs.microsoft.com/en-us/windows/uwp/get-started/whats-a-uwp
\subsection{Universal Windows Platform (\textit{UWP})}
Implementacja, która umożliwia tworzenie aplikacji dla wszystkich platform używających Windows 10, Xboxa, niektórych urządzeń stworzonych przez Microsoft i dostosowanych urządzeń IoT.

{\let\cleardoublepage\relax \chapter{ASP.NET MVC}}
\label{cha:wstep}
%https://msdn.microsoft.com/en-us/library/dd381412(v=vs.108).aspx

ASP.NET MVC jest frameworkiem do budowania aplikacji internetowych w oparciu o wzorzec architektoniczny Model-View-Controller (MVC). Wykorzystuje implementacje .NET Framework do uruchamiania skompilowanego kodu źródłowego.


\section{Model-Widok-Kontroler}

Większość dzisiejszych systemów komputerowych działa na zasadzie wyświetlania danych, które aktualnie znajdują się w bazie danych i ewentualnie ich modyfikacji. W celu ujednolicenia tych systemów stosowane jest wzorzec Model-Widok-Kontroler(ang. Model-View-Controller), który rozdziela logikę aplikacji na 3 główne segmenty:
\begin{enumerate}
	\item Model - Służy do pobierania, przechowywania i zamiany danych.
	\item Kontroler - przetwarza zapytania użytkownika, które przekazuje do modelu, który jest następnie wyświetlany jako widok.
	\item Widok - Służy do wyświetlania informacji 
\end{enumerate}

% Framework do budowania stron internetowych w oparciu o technologie .NET
\begin{figure}[h]
	\centering
	\includegraphics[height=50.5mm]{images/mvc.png}
	 \caption{Podać źródło}
\end{figure}

Cała aplikacja została skonstruowana zgodnie z tym wzorcem projektowym. ASP.NET MVC posiada wiele narzędzi, które ułatwiają zastosowanie tego wzorca. Dostarczana jest klasa bazowa \textbf{Controller}, która posiada wszystkie podstawowe metody do wyświetlania odpowiednich treści danych i zarządzania zapytaniami.

Wzorzec MVC niesie za sobą korzyści związane z warstwą wyświetlania danych. Jest to warstwa aplikacji, w której bardzo często dochodzi do zmian. Dzięki odseparowaniu danych od widoku jesteśmy w stanie tworzyć, jak i zmieniać widoki, bez wpływu na kod biznesowy aplikacji.

\section{Wzorzec Repozytorium\cite{RepositoryUnitOfWorkPattern}}

Wewnątrz aplikacji będziemy używać bazy danych Microsoft SQL.
Do komunikacji z bazą bardzo często jest tworzony kod, który zwraca podobne dane. W celu zmniejszenia redundancji kodu, jak i odseparowania zależności i odpowiedzialności wykorzystałem wzorzec Repozytorium (z ang. Repository Pattern).

Wzorzec ten wykorzystuje obiekty, zwane repozytoriami, których zadaniem jest pobieranie i modyfikowanie danych po stronie serwera SQL. Nie zawierają żadnej logiki biznesowej i są niezwiązane z resztą kodu danej aplikacji. 

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{images/RepositoryPattern.png}
	 \caption{Wzorzec repozytorium. Źródło: msdn.microsoft.com}
\end{figure}

\todo[inline]{źródło podmień?}

Wewnątrz projektu cały wzorzec repozytorium został oparty na interfejsach \textbf{IRepository} i \textbf{IRepository<T>} (który implementuje \textbf{IRepository}). W założeniu te interfejsy definiują operacje, które można zrealizować na danym obiekcie klasy 'T'. Informacje o tym jak te informacje są realizowane, jak i to, iż są one realizowane za pomocą bazy danych są przechowywane w klasie \textbf{RepositoryBase<T>}.
Wszystkie kolejne stworzone repozytoria dziedziczą po \textbf{RepositoryBase<T>} a ich interfejsy implementują \textbf{IRepository<T>}. 
Takie działanie pozwala nam na separację reprezentacji persystentnej (baza danych) i reprezentacji bieżącej (repozytoria). Wystarczy, iż zmienimy \textbf{RepositoryBase<T>} na jakąkolwiek inną klasę implementującą \textbf{IRepository<T>} i wykorzystamy ją w naszych repozytoriach. Dzięki temu możemy zastąpić Microsoft SQL inną implementacją.


\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{images/ReviewRepository.png}
	 \caption{Repozytorium ReviewCardRepository wraz z implementowanymi interfejsami i odziedziczonymi klasami.}
\end{figure}

\section{Jednostka Pracy\cite{RepositoryUnitOfWorkPattern}}
%https://docs.microsoft.com/en-us/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application

Wzorzec Jednostki Pracy (z ang. Unit of Work) ma na celu uporządkowanie pracy z repozytoriami za pomocą umieszczenia ich wszystkich w jednej klasie. Dodatkowo wszystkie repozytoria współdzielą kontekst dostępu do bazy danych. Zapisanie danych odbywa się poprzez wywołanie metody \textbf{SaveChanges} wewnątrz Jednostki Pracy (SaveChanges jest konwencją wewnątrz mojego projektu).

\begin{figure}[h]
	\centering
	\includegraphics{images/UnitOfWork.png}
	 \caption{Jednostka pracy wykorzystywana w projekcie.}
\end{figure}

\section{Mapowanie obiektowo-relacyjne}

Wewnątrz mojego projektu wykorzystałem narzędzie Entity Framework, które pozwala na korzystanie z mapowania obiektowo-relacyjnego. Dzięki tej technice mogę uprzednio zdefiniowane dane tabelaryczne odwzorować za pomocą klas, które zostaną stworzone na podstawie definicji tabeli i relacji między nimi. Powstałe klasy są używane wewnątrz kolekcji, implementujących interfejs \textbf{IQueryable<T>}, na których możemy wykonywać zapytania z pomocą \textbf{LINQ}a, które następnie zostaną przetłumaczone na zapytania SQL.
\\ \\
Takowe rozwiązanie ma wiele zalet :
\begin{enumerate}
	\item Dane z danej tabeli będziemy mogli otrzymać zawsze w tym samym formacie. Unika się dzięki temu sytuacji gdzie dana tabela ma wiele odpowiadających jej klas w kodzie, które służą jedynie do dostępu do danych.
	\item W przypadku zmiany typu w tabeli typ ten możemy bardzo prosto zmienić w kodzie.
	\item Zmniejsza to zakres potrzebnych umiejętności w celu używania danych występujących w bazie danych. Dany programista nie musi znać języka SQL, aby w sposób bezproblemowy pobrać interesujące go dane, nawet gdy tworzy bardzo skomplikowane zapytania.
	\item Łatwiejsza nawigacja po zależnościach między tabelami. Na danym typie możemy na przykład wykorzystać operacje \textbf{Find All References}, która wskaże nam użycia danego typu w naszym kodzie. W przypadku kodu SQL nie mielibyśmy takiej możliwości.
\end{enumerate}

\todo[inline]{Można napisać coś o lazy loading tego rozwiązania}

\section{Wstrzykiwanie zależności}

Wstrzykiwanie zależności (%ang. Dependency Injection) jest wzorcem projektowym, który jest łatwy do wykorzystywania wewnątrz aplikacji pisanych w ASP.NET MVC. Jego działanie polega na tym, iż obiekty naszej aplikacji nie muszą tworzyć zależnych od siebie obiektów, lecz są tworzone przez obiekt nadrzędny dla użytku tych klas. 

Informacja o tym, iż dana klasa ma zamiar używać instancji innej klasy może być zawarta poprzez odpowiednie wywołanie danej funkcji, bądź poprzez użycie listy interfejsów w konstruktorze, która zostanie wypełniona odpowiednimi instancjami.

W przypadku mojej aplikacji użyłem do tego biblioteki Ninject\cite{NinjectGithub}. Jest to bardzo popularna biblioteka realizująca wzorzec wstrzykiwania zależności. Dzięki niej możemy zdefiniować listę potrzebnych interfejsów/klas jako parametry konstruktora naszego kontrolera, a te utworzą się automatycznie podczas żądania użytkownika. Jeśli tworzone klasy także będą wymagały do swojego istnienia pewnych interfejsów bądź klas i zostanie to uściślone w ich konstruktorze to także dla nich zostaną dostarczone odpowiednie instancje.
\\ \\
Jednakże sam interfejs nie daje żadnej informacji o tym, jaką klasę należy zinstancjować, ponieważ może być wykorzystywany przez wiele klas pochodnych. W tym celu należy poinformować Ninject o tym, jakie klasy mają zostać zinstancjonowane poprzez zbindowanie interfejsów do odpowiednich klas. To działanie jest przedstawione na poniższym listingu:
\todo[inline]{Nie zawsze chodzi tylko o interfejsy - uściślić}
\begin{lstlisting}[frame=single, numbers=none,captionpos=b, 
caption={Przykładowy kod bindowania dla biblioteki Ninject}]
public static void RegisterServices(IKernel kernel)
{
kernel.Bind<FlashcardsEntities>().ToSelf().InRequestScope();
kernel.Bind<IFlashcardRepository>().To<FlashcardRepository>().InRequestScope();
}
\end{lstlisting}

Jak widzimy proces pojedynczego bindowania możemy podzielić na 2 części:

\begin{enumerate}
	\item Informacja o tym co powinno zostać stworzone przez Ninject gdy jest proszone o daną klasę
	\item Informacja o zasięgu współużywania danej instancji.
\end{enumerate}

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{images/ninject.png}
	 \caption{Proces bindowania z wyszczególnionymi częściami składowymi}
\end{figure}

Wewnątrz pierwszej części określamy jakim typem ma zostać zastąpiony dany typ w procesie wstrzykiwania. Na przykładzie widzimy, że typ może "zastąpić" sam siebie bądź może zostać użyty inny typ, który będzie jego instancją. Należy pamiętać, iż ten drugi typ musi implementować, dziedziczyć bądź być tym samym typem co pierwszy.
\\
%Fajnie tutaj byłoby to dać w jakąś ramkę czy coś
Ninject dodatkowo potrafi zbindować dany typ do \textbf{metody} lub klasy implementującej interfejs \textbf{Provider<T>}. Taka metoda, badź klasa musi zwrócić w wyniku swojego działania pełnoprawny obiekt danego typu.


%https://github.com/ninject/ninject/wiki/Object-Scopes
Ninject w swoim domyślnym zachowaniu za każdym razem jak poprosimy go obiekt danej klasy to tworzy on następny obiekt danej klasy. Jednakże często dochodzi do sytuacji, gdzie w danym segmencie kodu chcielibyśmy, aby obiekt danej klasy był współdzielony między wszystkimi instancjami wytworzonymi przez Ninject. Wtedy za każdym razem jak poprosimy obiekt klasy A to zawsze w ramach danego zasięgu dostaniemy ten sam obiekt i nie zostanie on utworzony ponownie.
Jest to szczególnie przydatne w środowisku serwerowym, gdy chcemy, aby dla każdego zapytania klienta wszystkie repozytoria i serwisy były zawsze takie same. Nie tylko nie ponosimy kosztów utworzenia danej instancji, lecz także współdzielone repozytoria mogą szybciej zwracać informacje odnośnie danych po stronie serwera SQL, gdy zobaczą, iż mają te dane w swoim cache'u.

\newpage
{\let\cleardoublepage\relax \chapter{Microsoft SQL Server}}

Microsoft SQL Server\cite{SqlServer} jest aplikacją, umożliwiającą zarządzanie serwerami baz danych. Został stworzony przez firmę Microsoft. Jego pierwsza edycja ukazała się w roku 1989.

Do tworzenia zapytań wykorzystano tutaj język Transact-SQL (T-SQL). Jest to rozszerzenie języka SQL (Structured Query Language), które między innymi wprowadza:

\begin{enumerate}
	\item Lokalne zmienne.
	\item Blok \textbf{Try Catch}, wspierający obsługę wyjątków.
	\item Dodatkowe funkcjonalności związane z obsługą tekstu, kalendarza i matematyki.
	\item Możliwość tworzenia pętli oraz instrukcji warunkowych.
	\item Procedury, funkcje składowane i wyzwalacze.
\end{enumerate} 

W celu integracji serwera Microsoft SQL z projektem napisanym w języku C\# należy pobrać paczkę NuGet\footnote{NuGet jest menadżerem paczek w środowisku .NET.\cite{Nuget}} o nazwie \textbf{System.Data.SqlClient}.




\newpage
{\let\cleardoublepage\relax \chapter{Testy}}

%wykorzystuje tutaj metodę bottom-up

Aplikacje tworzone w dzisiejszych czasach wymagają dostarczenia zestawu testów, których zadaniem jest sprawdzenie poprawności działania aplikacji. Z tego też powodu napisany został zestaw testów, które sprawdzają, czy poszczególne komponenty aplikacji działają poprawnie.

\section{Testy Jednostkowe}

Testy jednostkowe mają za zadanie sprawdzić poprawność działania pojedynczego modułu. Wszelkie odwołania do innych komponentów zostają zastąpione przez atrapy obiektów (po ang. mock objects), które symulują działanie ich prawdziwych odpowiedników.
 Wewnątrz projektu do operacji związanych z atrapami wykorzystany został framework Moq, który zawiera także dodatkowe funkcjonalności pozwalające ocenić czy dany test przebiegł poprawnie.
Testy zostały ułożone zgodnie ze wzorcem AAA\cite{UnitTestingMicrosoft} - Aranżacja (po ang. Arrange) Akcja (po ang. Act) Asercja (po ang. assert).  Dzięki temu testy są konsystentne i czytelne, przez co nie potrzeba dużej ilości czasu, aby zaznajomić się z nimi.

\begin{lstlisting}[frame=single, numbers=none,captionpos=b, 
caption={Przykładowy test jednostkowy wykorzystujący wzorzec AAA}]
public void StopLastTraining_assert_tests()
{
	//Aranżacja - stworzenie wewnętrznej atrapy obiektu dla atrapy serwisu
	mockTraining();
	//Akcja
	trainingReviewService.StopLastTraining();
	//Asercja - sprawdzenie poprawności wykonania
	trainingRepository.Verify(x => x.Remove(It.IsAny<long>()), Times.Once);
	unit.Verify(x => x.SaveChanges(), Times.Once); //wykorzystanie funkcjonalności frameworku Moq w celu sprawdzenia czy dana metoda została wywołana.
	Assert.AreEqual(null, sessionService.Object.UserInfo.TrainingInfo);
}
\end{lstlisting}

\section{Testy Integracyjne}

Testy integracyjne mają za zadanie wykryć potencjalne błędy występujące pomiędzy modułami. 

Takowe testy nie sprawdzają

\begin{lstlisting}[frame=single, numbers=none,captionpos=b, 
caption={Test integracyjny wykorzystany w projekcie.}]
[TestMethod]
public void ExistTest()
{
	using (var temp = new WindowsTempFile())
		Assert.IsTrue(File.Exists(temp.Path));
}}
\end{lstlisting}

\newpage
{\let\cleardoublepage\relax \chapter{Kaskadowe Arkusze Styli}}

Kaskadowe Arkusze Styli (po ang. Cascading Style Sheets, w skrócie CSS)\cite{CSSDoc} wykorzystywane są w celu opisu sposobu wyświetlania elementów stron WWW. Pozwalają zdefiniować między innymi takie właściwości elementów jak: kolory, czcionki, położenie. Dzięki oddzieleniu danych od sposobu ich wyświetlania możliwe jest wykorzystanie tych samych arkuszów styli na wielu stronach. 
W celu określenia wyglądu danego elementu należy zdefiniować odpowiednią regułę, na którą składa się :
\begin{enumerate}
	\item Selektor, który określa dla jakich elementów przeznaczona jest dana reguła.
	\item Zestaw właściwości wraz z przypisanymi do nich wartościami
\end{enumerate}

\begin{lstlisting}[frame=single, numbers=none,captionpos=b, 
caption={Przykład prostego selektora, który sprawi, iż wszystkie paragrafy będą miały domyślnie kolor pomarańczowy.}]
p //seletor p
{
//Właściwość color do której przypisano wartość orange
    color: orange;
}
\end{lstlisting}

\section{Syntaktycznie Zarąbiste Arkusze Styli}

W dzisiejszym świecie nikt obeznany z technologią tworzenia stron internetowych nie używa już czystego języka CSS do tworzenia arkuszy styli. 
Wynika to z faktu występowania zbyt dużej redundancji kodu, która jest związana z tym, iż niektóre fragmenty strony są formatowane zawsze w ten sam sposób (np. motyw kolorystyczny dla większości elementów jest ten sam). 

Jest to spowodowane brakiem zmiennych, szablonów, oraz innych konstrukcji, które pomogłoby w ograniczeniu powyższego problemu. 

Z tego też powodu powstały rozwiązania niedogodności występujących w języku CSS. Jednym z nich jest język SASS - Syntactically Awesome Style Sheets (z ang. Syntaktycznie Zarąbiste Arkusze Styli)\cite{Sass}. Jest on kompatybilny ze wszystkimi wersjami CSS, przez co każdy kod napisany w CSS jest z nim zgodny. Oferuje bardzo dużo funkcjonalności, między innymi:
\begin{enumerate}
	\item Zmienne, które pozwalają wielokrotnie używać danych wartości
	\item Możliwość zagnieżdżania reguł w innych regułach.
	\item Możliwość załączania plików pozwalająca na podział arkuszy styli.
	\item Mixin - szablony reguł, które można ponownie wykorzystywać.
	\item Dziedziczenie reguł za pomocą słówka kluczowego \textbf{@extend}
	\item Za pomocą operatorów \textbf{+}, \textbf{-}, \textbf{*}, \textbf{/}, \textbf{\%} można wykonywać operacjach na liczbach.
\end{enumerate}


\begin{lstlisting}[frame=single, numbers=none,captionpos=b, 
caption={Przykładowy kod SCSS wykorzystujący mixin.}]
@mixin border-radius($radius) {
  -webkit-border-radius: $radius;
     -moz-border-radius: $radius;
      -ms-border-radius: $radius;
          border-radius: $radius;
}

.box { @include border-radius(10px); }
\end{lstlisting}

\newpage
{\let\cleardoublepage\relax \chapter{Scala}}

Scala\cite{ScalaWiki} jest językiem programowania ogólnego zastosowania, który został wprowadzony na rynek przez Laboratorium "École Polytechnique Fédérale de Lausanne". Jest to język kompilowalny bezpośrednio do kodu bajtowego Javy, przez co programy w nim napisane z łatwością uruchamiają się w środowisku wykonywalnym maszyny wirtualnej Javy. 
Scala jest językiem wielo-paradygmatowym\cite{ScalaTour}. Korzysta z dobrodziejstw programowania funkcjonalnego i obiektowego.

\begin{lstlisting}[frame=single, numbers=none,captionpos=b, 
caption={Hello world napisany w języku Scala.}]
object HelloWorld {
  def main(args: Array[String]): Unit = {
    println("Hello, world!")
  }
}
\end{lstlisting}

\section{Javascript}

Javascript jest głównym językiem programowania wykorzystywanym na stronach internetowych. Może być on interpretowany bądź kompilowany metodą Just In Time, która kompiluje kod tuż przed jego wykonaniem. Jest to dynamiczny język wieloparadygmatowy bazujący na prototypach. Wspiera programowanie obiektowe, imperatywne i deklaratywne.\cite[AboutJS}
Javascript jako język posiada wiele problemów, które mogą doprowadzić do wystąpięnia błędów, między innymi takich jak:
\begin{enumerate}
	\item Niejawne rzutowania, które objawiają się przy użyciu operatora ==. Są przyczyną wielu trudnych do odkrycia błędów
	\item Automatyczne wstawianie średników, co może spowodować, iż program działa inaczej niż zamierzał to programista. Czasami potrafi to uratować program napisany przez programistę, lecz często prowadzi do dziwnych i niezrozumiałych błędów, takich jak w przypadku poniższego listingu: \ref{lst:javascriptSUCKS}
	\item Niezrozumiałe zachowana różnych funkcji. Metoda sortująca będzie domyślnie sortowała tablice liczb w porządku alfabetycznym nie zwracając uwagi na fakt, iż w tablicy nie występuje ani jeden ciąg znakowy.
	\item Zmienne, którym możemy w każdej chwili zmienić typ przechowywanej wartości. Z tego też powodu bardzo często powstają prozaiczne błędy, gdzie programista oczekując liczby w danym miejscu otrzymał ciąg znakowy co skutkuje błędem w dalszym kodzie programu.
\end{enumerate}

\begin{lstlisting}[label={lst:javascriptSUCKS},
frame=single, numbers=none,captionpos=b, 
caption={Przykład niepoprawnego kodu Javascript wynikłego z automatycznego wstawienia średnika}]
function foo() {
    return // Tutaj zostanie wstawiony średnik.
        {
            bar : "test"
        };
}
\end{lstlisting}


Z tego też powodu powstały języki, które starają się być lepsze i przyjaźniejsze dla programisty niż Javascript. Jest to między innymi: Typescript, Coffescript, Dart czy Scala.js. Takie języki programowania nie są wykonywane/kompilowane bezpośrednio w przeglądarce, lecz wpierw są kompilowane do kodu Javascript. Spowodowane jest to używaniem przez przeglądarki jedynie języka Javascript do wykonywania kodu\footnote{Wyjątkiem jest tutaj przeglądarka Dartium, która potrafi posiada maszynę wirtualną języka Dart\cite{Dartium}}. 

\begin{figure}[h]
	\centering
	\includegraphics{images/javagod.png}
	 \caption{Przykład dziwnego zachowania języka Javascript. Źródło: devrant.com}
\end{figure}

\section{Scala w wersji JS}

Scala.js jest językiem kompilowalnym do Javascripta, który umożliwia pozbycie się niedogodności związanych z używaniem języka Javascript. \cite{ScalaJS}. 



\begin{enumerate}
	\item Silne typowanie, dzięki któremu pisany kod nie zawiera bardzo prostych błędów.
	\item Podczas programowania nie trzeba się skupiać na dziwnych i frustrujących \hyperref[lst:javascriptSUCKS]{aspektach języka Javascript}.
\end{enumerate}


\subsection{sbt}
	

sbt (Simple Build Tool) jest narzędziem o otwartym kodzie źródłowym, pozwalającym na zarządzanie procesem budowania aplikacji napisanej w języku Scala lub Java. Jest to narzędzie bardzo rozbudowane, które m.in. umożliwia:
\begin{enumerate}
	\item Współpracę z wieloma narzędziami testującymi dla scali.
	\item Inkrementacyjne kompilowanie i testowanie.
	\item Zarządzanie zależnościami przy pomocy menadżera paczek Ivy.\cite{ApacheIvy}
	\item Ciąglą wdrażanie, kompilowanie i testowanie kodu.
\end{enumerate}

\hline{2cm}

W celu wykorzystania naszej aplikacji należy użyć polecenia \textbf{sbt new sbt/scala-seed.g8}, które spowoduje utworzenie minimalnego projektu Scali, który możemy dostosować do własnych potrzeb.
Z tego też powodu musimy wykonać parę istotnych zmian w projekcie, aby był on kompilowalny do języka Javascript za pomocą Scali.js.

\begin{enumerate}
	\item Należy dodać plik ./project/plugins.sbt\footnote{./ jest katalogiem głównym projektu w tym przypadku.}, wewnątrz którego znajdzie się instrukcja \textbf{addSbtPlugin("org.scala-js" \% "sbt-scalajs" \% "0.6.20")}, która informuje o tym, iż chcemy użyć Scali.JS
	\item W pliku ./project/build.properties musimy określić wersje używanego przez nas narzędzia sbt poprzez dodanie bądź zmodyfikowanie linijki: 
	\begin{lstlisting}[numbers = none]
		sbt.version=0.13.16
	\end{lstlisting}
	\item Następnie musimy zmodyfikować plik build.sbt znajdujący się w głównym folderze projektu. Przykładowy plik, który jest używany w projekcie, znajduje się na listingu \ref{lst:scalasbt}.
\end{enumerate}


\begin{lstlisting}[label={lst:scalasbt},
frame=single, numbers=none,captionpos=b, 
caption={Plik .sbt, który jest wykorzystywany w projekcie.}]
enablePlugins(ScalaJSPlugin)
libraryDependencies += "org.scala-js" %%% "scalajs-dom" % "0.9.1"
libraryDependencies += "be.doeraene" %%% "scalajs-jquery" % "0.9.1"

name := "Flashcards"
scalaVersion := "2.12.2"

// Informacja o tym, iż chcemy aby nasz kod zawsze miał uruchamianą metodę main po wczytaniu witryny.
scalaJSUseMainModuleInitializer := true

skip in packageJSDependencies := false
jsDependencies += "org.webjars" % "jquery" % "2.1.4" / "2.1.4/jquery.js" 
jsDependencies += "org.webjars.bower" % "jsrender" % "1.0.0-rc.70" / "1.0.0-rc.70/jsrender.js"
\end{lstlisting}

%Scala jest zorientowana obiektowo ze względu na to, iż każda zmienna jest obiektem. Mamy do wykorzystania klasy i cechy (ang. traits), wraz z mechanizmami dziedziczenia. Pozwala to odwzorować 

\subsection{Proces budowania projektu}

Projekt kompilacji projektu jest podzielony na 3 etapy\cite{HandsOnScalaPipeline}:
\begin{enumerate}
	\item Początkową kompilację
	\item Szybką optymalizację
	\item Pełną optymalizację (Opcjonalny)
\end{enumerate}

\subsubsection{Początkowa kompilacja}

W trakcie kompilacji pliki .scala są kompilowane do plików .class i .sjsir. 
Pliki .class nie biorą udziału w tworzeniu kodu javascript. Ich zadaniem jest współpraca z innymi narzędziami, które być może będą ich używać. Przykładem takiego narzędzia może być \textbf{IntelliJ} lub \textbf{Eclipse}, które plików .class używają w celu wspomagania programisty w trakcie pisania kodu.
Pliki .sjsir (Nazwa rozszerzenia jest skrótem od \"ScalaJS Intermediate Representation")\cite{ScalaCompilationProcess} zawierają kod przejściowy między Scalą a Javascriptem. Większość konstrukcji została zastąpiona przez ekwiwalenty z języka Javascript. 
Gdybyśmy połączyli wszystkie pliki .sjsir, wyprodukowane przez sbt to ich wynikiem byłby plik większy niż 20 MB. Wynika to z faktu, iż w tym pliku nadal znajduje się wiele niepotrzebnych bibliotek i konstrukcji. Jak na przykład \textbf{cała} biblioteka standardowa Scali.


\begin{lstlisting}[label={lst:scalasbt},
frame=single, numbers=none,captionpos=b, 
caption={Przykładowy plik .sjsir dla projektu wyświetlającego HelloWorld na ekranie.}]
module class Ltutorial_webapp_TutorialApp$ extends O {
  def main__AT__V(args: T[]) {
    this.appendPar__Lorg_scalajs_dom_raw_Node__T__V
    (mod:Lorg_scalajs_dom_package$.document__Lorg_scalajs_dom_raw_HTMLDocument()["body"], "Hello World")
  }
  def appendPar__Lorg_scalajs_dom_raw_Node__T__V(targetNode: any, text: T) {
    val parNode: any = mod:Lorg_scalajs_dom_package$.document__Lorg_scalajs_dom_raw_HTMLDocument()
    ["createElement"]("p");
    val textNode: any = mod:Lorg_scalajs_dom_package$.document__Lorg_scalajs_dom_raw_HTMLDocument()
    ["createTextNode"](text);
    parNode["appendChild"](textNode);
    targetNode["appendChild"](parNode)
  }
  def init___() {
    this.O::init___();
    mod:Ltutorial_webapp_TutorialApp$<-this
  }
}
\end{lstlisting}

\subsubsection{Szybka optymalizacja}

W celu optymalizacji poprzedniego kroku stosuje się szybką optymalizację kodu .sjsir, która jako rezultat swej pracy stworzy kod Javascript. W tym celu należy użyć optymalizatora FastOptJS poprzez wpisanie komendy \textbf{FastOptJS} w sbt. Optymalizacja ma na celu:
\begin{enumerate}
	\item Wyeliminowanie fragmentów kodu, które są nieużywane. Na przykład kod biblioteki standardowej, który nie zostanie wywołany.
	\item Inline'owanie małych funkcji. Zmniejsza to koszt wywołań i wielkość kodu.
	\item Zmiana zmiennych na stałe, jeśli ich wartość jest znana w trakcie kompilacji.
\end{enumerate}

Dzięki tej operacji kod wykonywalny zmniejszy się z 20 MB do 1.5-2.5MB\cite{ScalaCompilationProcess}.


\subsubsection{Pełna optymalizacja}

Kod, który jest tworzony przez Scala.js jest zgodny z restrykcjami narzuconymi przez kompilator Closure\cite{Closure}. Jest to narzędzie stworzone przez firmę Google, które potrafi optymalizować kod Javascriptowy.\cite{ClosureCompiler} Celem tego kroku jest zmniejszenie rozmiaru pliku javascript i uczynienie konstrukcji w nim występujących bardziej wydajnymi.
W wyniku tego procesu otrzymywany jest plik wykonywalny o rozmiarze między 150KB do kilkuset KB\cite{ScalaCompilationProcess}.
W celu użycia pełnej optymalizacji należy wywołać polecenie \textbf{FullOptJS} w sbt.

\subsubsection{Pliki javascript}

W wyniku działań optymalizatorów tworzone są poniższe pliki javascript. Należy mieć na uwadze fakt, iż pliki bibliotek muszą zostać dołączone do kodu strony przed plikiem z kodem wykonywalnym.

\todo[inline]{Dodać nagłówki do tabeli wyjasniające co zawiera dana kolumna}
\begin{center}
\begin{tabular}{| l | l | p{8cm} |}
\hline
Typ kompilacji & Wytworzony plik & Zawartość pliku \\ \hline
FastOptJS & scala-js-[Nazwa-Projektu]-fastopt.js & Plik z kodem wykonywalnym \\ \hline

FastOptJS & scala-js-[Nazwa-Projektu]-fastopt.js.map & Plik mapujący kod Scali do kodu Javascript. \\ \hline

FastOptJS & scala-js-[Nazwa-Projektu]-jsdeps.js & Plik z kodem zewnętrznych bibliotek użytych w procesie tworzenia aplikacji \\ \hline

 \hline \hline

FullOptJS & scala-js-[Nazwa-Projektu]-opt.js & Plik z kodem wykonywalnym \\ \hline

FullOptJS & scala-js-[Nazwa-Projektu]-opt.js.map & Plik mapujący kod Scali do kodu Javascript. \\ \hline

FullOptJS & scala-js-[Nazwa-Projektu]-jsdeps.min.js & Plik z kodem zewnętrznych bibliotek użytych w procesie tworzenia aplikacji. \\ \hline
\hline
\end{tabular}
\end{center}
\subsubsection{Debugowanie}


Jednym z najważniejszych procesów, które na celu mają znalezienie błędów w powstałym kodzie jest debugowanie. Proces debugowania aplikacji powinien umożliwiać programiście przynajmniej możliwość zatrzymania kodu w dowolnym miejscu, podejrzenia kodu źródłowego jak i możliwość odczytu i modyfikacji zmiennych.
Kod stworzony za pomocą kompilatora scala.js jest bardzo łatwy w debugowaniu. Przeglądarki posiadają możliwość dołączenia mapy kodów źródłowych, które do danych linijek kodu javascript przypisują ich odpowiedniki w pliku źródłowym. Umożliwia to prace z oryginalnym kodem źródłowym podczas używania przeglądarki internetowej. 
Pliki z mapami źródłowymi mają format \textbf{\{SkompilowanyPlik\}.map}, gdzie SkompilowanyPlik jest artefaktem naszego procesu kompilacji, np.  \textbf{scala-js-[Nazwa-Projektu]-fastopt.js}. 
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{images/debug.png}
	 \caption[Przykład procesu debugowania kodu. Nasz program zostaje zatrzymany na linijce przed dodaniem napisu Hello World.]
	 {Przykład procesu debugowania kodu. Nasz program zostaje zatrzymany na linijce przed dodaniem napisu Hello World. \footnotemark}
\end{figure}

\footnotetext{Na obrazku na stronie widnieje już napis Hello World. Jest to artefakt, który został stworzony przy poprzednim uruchomieniu strony i jeszcze się nie odświeżył.}


\subsection{Hello World}

\todo[inline]{Warto jest robić tą sekcję gdzie opisze proces tworzenia hello worlda? Nie będe tego aktualnie pisał bo tylko będe tracił czas jeśli jest to zbedne. Ale z chęcią bym to opisał. Czyli jakie pliki źródłowe utworzyć i podać minimalny kod aby odpalić kod.}
